#!/usr/bin/env node

/**
 * Trinity Protocol Integration Script
 * Integrates @canvastack/trinity package into main project
 * 
 * EXECUTION: node scripts/trinity-integration.cjs
 * PURPOSE: Zero-regression integration of Trinity Protocol
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('üõ°Ô∏è TRINITY PROTOCOL - Main Project Integration');
console.log('===============================================\n');

class TrinityIntegrator {
    constructor() {
        this.projectRoot = process.cwd();
        this.trinityPackagePath = path.join(this.projectRoot, 'packages', 'canvastack', 'trinity');
        this.packageJsonPath = path.join(this.projectRoot, 'package.json');
        this.scriptsPath = path.join(this.projectRoot, 'scripts');
        
        this.log('üöÄ Initializing Trinity Integration...');
        this.log(`üìÅ Project Root: ${this.projectRoot}`);
        this.log(`üì¶ Trinity Package: ${this.trinityPackagePath}`);
    }

    log(message) {
        console.log(`[TRINITY-INTEGRATION] ${message}`);
    }

    error(message) {
        console.error(`[TRINITY-ERROR] ${message}`);
    }

    success(message) {
        console.log(`[TRINITY-SUCCESS] ‚úÖ ${message}`);
    }

    // Step 1: Verify Trinity Package exists and is functional
    verifyTrinityPackage() {
        this.log('üîç Step 1: Verifying Trinity Package...');
        
        if (!fs.existsSync(this.trinityPackagePath)) {
            throw new Error(`Trinity package not found at ${this.trinityPackagePath}`);
        }

        const trinityPackageJson = path.join(this.trinityPackagePath, 'package.json');
        if (!fs.existsSync(trinityPackageJson)) {
            throw new Error('Trinity package.json not found');
        }

        const trinityPkg = JSON.parse(fs.readFileSync(trinityPackageJson, 'utf8'));
        this.log(`üì¶ Trinity Package Version: ${trinityPkg.version}`);

        // Test Trinity CLI
        try {
            const trinityBin = path.join(this.trinityPackagePath, 'bin', 'trinity');
            if (fs.existsSync(trinityBin)) {
                this.success('Trinity CLI binary found');
            }
        } catch (error) {
            this.error(`Trinity CLI test failed: ${error.message}`);
        }

        this.success('Trinity Package verification complete');
        return true;
    }

    // Step 2: Install Trinity Package as local dependency
    installTrinityPackage() {
        this.log('üì¶ Step 2: Installing Trinity Package...');

        try {
            // Read current package.json
            const packageJson = JSON.parse(fs.readFileSync(this.packageJsonPath, 'utf8'));
            
            // Add Trinity package as dependency
            if (!packageJson.dependencies) {
                packageJson.dependencies = {};
            }
            
            // Use relative path for local package
            packageJson.dependencies['@canvastack/trinity'] = `file:./packages/canvastack/trinity`;
            
            // Write updated package.json
            fs.writeFileSync(this.packageJsonPath, JSON.stringify(packageJson, null, 2));
            this.success('Added Trinity dependency to package.json');

            // Install dependencies
            this.log('üì• Installing dependencies...');
            execSync('npm install', { stdio: 'inherit', cwd: this.projectRoot });
            
            this.success('Trinity package installation complete');
        } catch (error) {
            throw new Error(`Failed to install Trinity package: ${error.message}`);
        }
    }

    // Step 3: Create Trinity configuration for main project
    createTrinityConfig() {
        this.log('‚öôÔ∏è Step 3: Creating Trinity Configuration...');

        const configPath = path.join(this.projectRoot, 'trinity.config.js');
        
        const configContent = `/**
 * Trinity Protocol Configuration for Wedding Invite Project
 * Generated by Trinity Integration Script
 */

module.exports = {
    // Project metadata
    name: "Wedding Invite Event Management System",
    version: "2.0.0",
    description: "Multi-tenant event management system with RSVP enhancements",
    
    // Trinity validation settings
    validation: {
        strictMode: false,  // Allow gradual adoption
        skipPatterns: [
            "node_modules/**",
            "dist/**",
            "build/**",
            "__tests__/archived/**",
            "packages/canvastack/trinity/**"  // Skip self-validation
        ],
        testCoverage: {
            minimum: 70,  // Realistic target for existing project
            exclude: ["*.config.js", "*.test.js"]
        }
    },

    // Integration settings
    integration: {
        hooks: {
            preCommit: false,    // Disabled for initial integration
            prePush: false,      // Disabled for initial integration
            midDev: true,        // Enable for development feedback
            comprehensive: true   // Enable for full validation
        },
        reporting: {
            console: true,
            json: true,
            html: false  // Disable HTML for now
        }
    },

    // Project structure mapping
    structure: {
        src: "./src",
        tests: "./__tests__",
        docs: "./docs",
        database: "./database",
        scripts: "./scripts"
    },

    // RSVP Enhancement specific settings
    rsvpEnhancement: {
        phase: "FASE_2",
        trinityCompliant: true,
        features: [
            "real-time-tracking",
            "analytics-dashboard", 
            "notification-system",
            "multi-tenant-support"
        ]
    }
};
`;

        fs.writeFileSync(configPath, configContent);
        this.success(`Trinity configuration created at ${configPath}`);
    }

    // Step 4: Update package.json scripts
    updatePackageScripts() {
        this.log('üìù Step 4: Updating package.json scripts...');

        const packageJson = JSON.parse(fs.readFileSync(this.packageJsonPath, 'utf8'));
        
        if (!packageJson.scripts) {
            packageJson.scripts = {};
        }

        // Add Trinity validation scripts
        packageJson.scripts['trinity:validate'] = 'npx @canvastack/trinity validate';
        packageJson.scripts['trinity:init'] = 'npx @canvastack/trinity init';
        packageJson.scripts['trinity:watch'] = 'npx @canvastack/trinity watch';
        packageJson.scripts['trinity:report'] = 'npx @canvastack/trinity validate --mode comprehensive --output json';
        
        // Add combined scripts
        packageJson.scripts['test:trinity'] = 'npm run test && npm run trinity:validate';
        packageJson.scripts['dev:trinity'] = 'npm run trinity:watch & npm run dev';
        
        fs.writeFileSync(this.packageJsonPath, JSON.stringify(packageJson, null, 2));
        this.success('Package scripts updated with Trinity commands');
    }

    // Step 5: Create integration validation script
    createValidationScript() {
        this.log('üß™ Step 5: Creating integration validation script...');

        const validationScriptPath = path.join(this.scriptsPath, 'validate-trinity-integration.cjs');
        
        const validationContent = `#!/usr/bin/env node

/**
 * Trinity Integration Validation Script
 * Validates zero-regression Trinity integration
 */

const { execSync } = require('child_process');
const path = require('path');

console.log('üõ°Ô∏è TRINITY INTEGRATION VALIDATION');
console.log('=====================================\\n');

class IntegrationValidator {
    constructor() {
        this.passed = 0;
        this.failed = 0;
    }

    test(name, fn) {
        try {
            console.log(\`üß™ Testing: \${name}\`);
            fn();
            console.log(\`‚úÖ PASSED: \${name}\\n\`);
            this.passed++;
        } catch (error) {
            console.error(\`‚ùå FAILED: \${name}\`);
            console.error(\`   Error: \${error.message}\\n\`);
            this.failed++;
        }
    }

    run() {
        console.log('Starting Trinity integration validation...\\n');

        this.test('Trinity Package Import', () => {
            try {
                require('@canvastack/trinity');
            } catch (error) {
                throw new Error(\`Cannot import Trinity package: \${error.message}\`);
            }
        });

        this.test('Trinity CLI Available', () => {
            try {
                execSync('npx @canvastack/trinity --version', { stdio: 'pipe' });
            } catch (error) {
                throw new Error('Trinity CLI not accessible');
            }
        });

        this.test('Trinity Configuration Valid', () => {
            const fs = require('fs');
            const configPath = './trinity.config.js';
            if (!fs.existsSync(configPath)) {
                throw new Error('Trinity configuration not found');
            }
            
            try {
                const config = require(path.resolve(configPath));
                if (!config.name || !config.validation) {
                    throw new Error('Invalid Trinity configuration structure');
                }
            } catch (error) {
                throw new Error(\`Configuration error: \${error.message}\`);
            }
        });

        this.test('Existing Tests Still Pass', () => {
            try {
                // Run a quick subset of existing tests to ensure no regression
                execSync('npm run test -- --testNamePattern="simple" --testTimeout=10000', { 
                    stdio: 'pipe',
                    timeout: 30000
                });
            } catch (error) {
                throw new Error('Existing tests regression detected');
            }
        });

        this.test('Trinity Validation Runs', () => {
            try {
                execSync('npm run trinity:validate', { 
                    stdio: 'pipe',
                    timeout: 60000
                });
            } catch (error) {
                // Trinity validation might report issues, but shouldn't crash
                if (error.status === undefined) {
                    throw new Error('Trinity validation crashed');
                }
            }
        });

        console.log('\\nüìä VALIDATION SUMMARY');
        console.log('======================');
        console.log(\`‚úÖ Passed: \${this.passed}\`);
        console.log(\`‚ùå Failed: \${this.failed}\`);
        
        if (this.failed === 0) {
            console.log('\\nüéâ TRINITY INTEGRATION SUCCESSFUL!');
            console.log('Zero functionality regression confirmed.');
            process.exit(0);
        } else {
            console.log('\\n‚ùå TRINITY INTEGRATION ISSUES DETECTED');
            console.log('Please review failed tests above.');
            process.exit(1);
        }
    }
}

const validator = new IntegrationValidator();
validator.run();
`;

        fs.writeFileSync(validationScriptPath, validationContent);
        fs.chmodSync(validationScriptPath, 0o755);
        this.success('Integration validation script created');
    }

    // Main integration process
    async integrate() {
        try {
            console.log('üöÄ Starting Trinity Protocol Integration...\n');

            this.verifyTrinityPackage();
            this.installTrinityPackage();
            this.createTrinityConfig();
            this.updatePackageScripts();
            this.createValidationScript();

            console.log('\nüéâ TRINITY INTEGRATION COMPLETE!');
            console.log('===============================\n');
            console.log('Next steps:');
            console.log('1. Run: npm run trinity:validate');
            console.log('2. Run: node scripts/validate-trinity-integration.cjs');
            console.log('3. Test existing functionality to ensure zero regression');
            console.log('\nTrinity Protocol is now integrated into your main project! üõ°Ô∏è');

        } catch (error) {
            console.error('\n‚ùå TRINITY INTEGRATION FAILED');
            console.error('==============================');
            console.error(`Error: ${error.message}`);
            process.exit(1);
        }
    }
}

// Run integration if called directly
if (require.main === module) {
    const integrator = new TrinityIntegrator();
    integrator.integrate();
}

module.exports = TrinityIntegrator;